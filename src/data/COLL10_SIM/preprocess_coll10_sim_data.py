# read the simulation data from the data/COLL10_SIM/sim_data/all_synthetic_data_N60.pt
# read the data and create a csv data file all_data_time_not_normed.csv
# with the following columns:
# user_session, task_label, data_type, metric, result, presentation_time
# the .pt file is generated by the generate_simulation_data.py script -- refer to the script for more details

import torch
import pandas as pd
import numpy as np
# Load the .pt file
data = torch.load('./sim_data/all_synthetic_data_N200.pt')

# Initialize an empty list to store the processed data
processed_data = []

data_types = ["binary", "timing", "binarySpan"]

# Iterate over the synthetic data
for synthetic_run_id, synthetic_data in data.items():
    # Extract base ID and run number
    base_id = '_'.join(synthetic_run_id.split('_')[:-1])  # Everything before last _
    run_num = int(synthetic_run_id.split('_')[-1].replace('sim',''))
    
    # Skip if run number > 50
    if run_num > 50:
        continue
        
    for metric, results in synthetic_data.items():
        # Set random seed for reproducibility
        np.random.seed(42 + run_num)  # Different seed per run
        
        # Randomly select sampling rate from [0.1, 0.3, 0.5, 0.7]
        sampling_rate = np.random.choice([0.1, 0.3, 0.5, 0.7, 1])
        
        # Calculate number of results to keep
        n_results = len(results)
        n_keep = min(60, int(np.ceil(n_results * sampling_rate))) # keep at most 60 observations
        # Randomly select indices to keep
        keep_indices = np.random.choice(n_results, size=n_keep, replace=False)
        
        # Only process selected results
        for idx, result in enumerate(results):
            if idx not in keep_indices:
                continue
                
            # Use full synthetic run ID as user session
            user_session = synthetic_run_id
            
            # Append the processed data
            processed_data.append({
                "user_session": user_session,
                "task_label": "CorsiComplex" if "CorsiComplex" in metric else "SimpleSpan" if "SimpleSpans" in metric else metric,
                "data_type": "timing" if "reaction_time" in metric else "binarySpan" if ("Simple" in metric or "Complex" in metric) else "binary", 
                "metric": metric,
                "result": result,
                "presentation_time": None,  # Assuming no presentation time in synthetic data
            })

# Convert the processed data to a DataFrame
processed_data_df = pd.DataFrame(processed_data)

# Save the DataFrame to a CSV file
processed_data_df.to_csv('all_data_time_not_normed.csv', index=False)




